#!/usr/bin/env python3

"""
mango
> a simple script manager

This is the main instance of the mango script, and will automatically be placed in a path-included folder by the Mango Bootstrap.

A typical mango repository is formulated as follows:
- folder (called a mango repository)
    - .mango (called the mango entrypoint)
        - .instructions (lists all instructions within this repository)
        - all scripts of this repository
"""

import argparse
import os
import sys
import subprocess

__version__ = "2.0.0-alpha"
epilog_message = '''\
usage: mango [-h] command ...

Mango: a simple script manager

positional arguments:
  command     The command to run. Host commands start with @
  args        Arguments to pass to the command

options:
  -h, --help  show this help message and exit

Mango comes with a default set of host commands, which you can call using @.

Call `mango @help` to invoke the help command for the builtins library. To view help for a specific entry, call `mango @help <command>`.
'''

def existMangoRepo(scan_path_str: str) -> bool:
    """check whether a directory is a mango repository

    Keyword arguments:
    - scan_path_str -- the string of the directory to check
    
    Return: bool for whether the directory is a mango repository
    """
    
    return os.path.exists(os.path.join(scan_path_str, ".mango"))

def closestMangoRepo() -> str:
    """find the first mango repository up the directory tree, raises a FileNotFoundError if none is found

    Return: string for the path of the closest mango repository
    """
    
    cur_exec_path_str = os.getcwd()
    while cur_exec_path_str != "/":
        if existMangoRepo(cur_exec_path_str):
            return cur_exec_path_str
        cur_exec_path_str = os.path.dirname(cur_exec_path_str)
    raise FileNotFoundError("mango repository not found")

def splitCommand(command_str: str) -> tuple[str, str]:
    """splits a command and returns (submodule_path, binding)
    
    Format: (sub1:sub2:)binding
    
    Keyword arguments:
    - command_str -- the command string to split
    
    Return: a tuple corresponding to (submodule_path, binding)
    """
    
    if ':' in command_str:
        split_command = command_str.split(':')
        binding = split_command[-1]
        submodule_path = ':'.join(split_command[:-1])
        return submodule_path, binding
    else:
        return "", command_str

def mapSubmodulePath(submodule_path_str: str, base_path: str = ".", appendReturn: bool = False) -> str:
    """maps a submodule path to its real os path, relative to the parent .mango folder
    
    Keyword arguments:
    - submodule_path_str -- the submodule path to map
    - base_path -- base directory used to resolve the submodule path
    Return: the real os path of the submodule, relative to the base path
    """
    
    os_path = "."
    if not submodule_path_str:
        return os_path
    for submodule in submodule_path_str.split(':'):
        os_path = os.path.join(os_path, ".submodules", submodule)
    candidate_path = os.path.join(base_path, os_path)
    if not os.path.exists(candidate_path):
        raise FileNotFoundError("submodule path does not exist")
    if appendReturn:
        return candidate_path
    else:
        return os_path

def mangoFind(mango_path_str: str, command: str) -> tuple[str | None, bool]:
    """find the script that corresponds to a command in a mango module
    
    Keyword arguments:
    - mango_path_str -- the path to the .mango folder
    - command_name -- the command typed in by the user
    
    Return: the path to the script if it exists, None if not
    """
    
    print(f"Called: mangoFind({mango_path_str}, {command})", file=sys.stderr)
    
    def handleExport(rest: str, cmd: str) -> tuple[str | None, bool]:
        if not rest:
            print("Invalid @export command", file=sys.stderr)
            raise SyntaxError("invalid @export command")
        try:
            submodule_os_path = os.path.join(mango_path_str, mapSubmodulePath(rest, base_path=mango_path_str))
        except FileNotFoundError:
            return None, False
        # If the command includes a submodule path, we need to handle it differently
        if ':' in cmd:
            submodule_path, binding = splitCommand(cmd)
            # Split the submodule path into parts
            path_parts = submodule_path.split(':')
            if path_parts[0] == rest:
                remaining_path = ':'.join(path_parts[1:])
                cmd = f"{remaining_path}:{binding}" if remaining_path else binding
        return mangoFind(submodule_os_path, cmd)
    
    try:
        submodule_path, binding = splitCommand(command)
        try:
            mapped_mango_path = os.path.join(mango_path_str, mapSubmodulePath(submodule_path, base_path=mango_path_str))
        except FileNotFoundError:
            return None, False
        with open(os.path.join(mapped_mango_path, ".instructions"), "r") as instructions_file:
            for line in instructions_file:
                line = line.strip()
                # print(line)
                if (len(line) == 0 or line.startswith("#")):
                    continue
                if line.startswith('@'):
                    # derivative command
                    derivative: str= line.split()[0]
                    if derivative == "@export":
                        # syntax: @export SUBMODULE_PATH
                        rest = line[len(derivative):].strip()
                        callback = handleExport(rest, command)
                        if callback[0] is not None:
                            return callback
                        else:
                            continue
                    raise SyntaxError("invalid derivative command: " + derivative)
                use_source = False
                if line.startswith('*'):
                    use_source = True
                    line = line[1:]
                colon_count = line.count(":")
                if colon_count == 0:
                    raise SyntaxError("a non-derivative command must have a binding field")
                elif colon_count == 1:
                    script, bindings = line.split(":")
                    bindings = bindings.split()
                    if binding in bindings:
                        return os.path.join(mapped_mango_path, script), use_source
                else:
                    # This is a rebind command, exporting a binding from a submodule
                    # syntax: submodule:submodule:binding: new-binding1 new-binding2
                    parts = line.split(":")
                    bindings = parts[-1].strip().split()
                    if binding not in bindings:
                        continue
                    # Reconstruct the submodule path and the new command
                    submodule_path = ':'.join(parts[:-2])
                    old_binding = parts[-2].strip()
                    print(f"Rebinding {old_binding} from {submodule_path} to {binding}", file=sys.stderr)
                    print(f"Base path: {mapped_mango_path}", file=sys.stderr)
                    return mangoFind(mapSubmodulePath(submodule_path, base_path=mango_path_str, appendReturn=True), old_binding)
        return None, False
    except Exception as e:
        print("Error occurred when parsing repo: " + mango_path_str, file=sys.stderr)
        raise SyntaxError("invalid .instructions file") from e

def mangoFindFromRepo(repo_path_str: str, command: str) -> tuple[str | None, bool]:
    """find the script that corresponds to a command in a mango repository
    
    Keyword arguments:
    - repo_path_str -- the string the mango repository
    - command -- the command typed in by the user
    
    Return: the path to the script if it exists, None if not
    """
    
    if not existMangoRepo(repo_path_str):
        return None, False
    return mangoFind(os.path.join(repo_path_str, ".mango"), command)

def mangoRecursiveFindFromRepo(repo_path_str: str, command: str) -> tuple[str | None, bool]:
    """find the script that corresponds to a command in a mango repository, recursively, by going up the directory tree
    
    Keyword arguments:
    - repo_path_str -- the string the mango repository
    - command -- the command typed in by the user, with the host flag `@` removed
    
    Return: the string of the script if it exists, None if not
    """
    while repo_path_str != "/":
        script_path, use_source = mangoFindFromRepo(repo_path_str, command)
        if script_path is not None:
            return script_path, use_source
        repo_path_str = os.path.dirname(repo_path_str)
    return None, False

def mangoExecute(script_path_str: str, args: list[str], use_source: bool) -> None:
    """execute a script with arguments
    
    Keyword arguments:
    - script_path_str -- the string of the script to execute
    - args -- the list of arguments to pass to the script
    - use_source -- whether to source the script instead of executing it in a separate shell
    """
    
    if use_source:
        # start a sub-shell with the exact same environment as the current shell
        # join the script and the shell launch with && to prepare the environment
        # this should mimic the effect of sourcing the script
        pre_command = f"source {script_path_str} {' '.join(args)} && exec $SHELL"
        pre_env = os.environ.copy()
        pre_env.update({"MANGO_SOURCE": "true"})
        subprocess.run(
            pre_command, shell=True, executable="/bin/bash", env=pre_env, check=True
        )
    else:
        os.system(f"{script_path_str} " + " ".join(args))

def mango():
    """the main function for the mango script
    """
    
    parser = argparse.ArgumentParser(
        description="Mango: a simple script manager",
        epilog=epilog_message,
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument('-v', '--version', action='version', version=f'Mango {__version__}')
    parser.add_argument('-s', '--source', action='store_true', help="source the script instead of executing it in a separate shell")
    parser.add_argument("command", help="The command to run. Host commands start with @")
    parser.add_argument("args", nargs=argparse.REMAINDER, help="Arguments to pass to the command", default=[])
    args = parser.parse_args()
    script = None
    use_source = args.source
    
    try:
        if (args.command.startswith("@")):
            # this is a host command
            command = args.command[1:]
            script, enforce_source = mangoRecursiveFindFromRepo(closestMangoRepo(), command)
            if script is None:
                print(f"Command '{command}' not found in any repo. Should it exist?", file=sys.stderr)
                return
        else:
            # this is a normal command
            script, enforce_source = mangoFindFromRepo(closestMangoRepo(), args.command)
            if script is None:
                print(f"Command '{args.command}' not found in the current repo. Should it exist?", file=sys.stderr)
                return
        # execute the script
        # if the source is used, a new bash will be spawned and will take over the current python process
        mangoExecute(script, args.args, use_source=use_source or enforce_source)
    except FileNotFoundError as e:
        if str(e) == "mango repository not found":
            print("No mango repository found in any directory. Where's your home mango I wonder :P", file=sys.stderr)
        else:
            raise
    except SyntaxError as e:
        if str(e) == "invalid .instructions file":
            print("Invalid .instructions file. Does it exist? Or is there something wrong with it :<", file=sys.stderr)
        else:
            raise
    except:
        print("An unknown error occurred. I'm sorry, I'm not sure what happened :(", file=sys.stderr)
        raise

if __name__ == '__main__':
    mango()