#!/usr/bin/env python3

"""
mango
> a simple script manager

This is the main instance of the mango script, and will automatically be placed in a path-included folder by the Mango Bootstrap.

A typical mango repository is formulated as follows:
- folder (called a mango repository)
    - .mango (called the mango entrypoint)
        - .instructions (lists all instructions within this repository)
        - all scripts of this repository
"""

import argparse
import os
import sys
import subprocess

__version__ = "2.0.0-alpha"
epilog_message = '''\
usage: mango [-h] command ...

Mango: a simple script manager

positional arguments:
  command     The command to run. Host commands start with @
  args        Arguments to pass to the command

options:
  -h, --help  show this help message and exit

Mango comes with a default set of host commands, which you can call using @.

Call `mango @help` to invoke the help command for the builtins library. To view help for a specific entry, call `mango @help <command>`.
'''

def existMangoRepo(scan_path_str: str) -> bool:
    """check whether a directory is a mango repository

    Keyword arguments:
    - scan_path_str -- the string of the directory to check
    
    Return: bool for whether the directory is a mango repository
    """
    
    return os.path.exists(os.path.join(scan_path_str, ".mango"))

def closestMangoRepo() -> str:
    """find the first mango repository up the directory tree, raises a FileNotFoundError if none is found

    Return: string for the path of the closest mango repository
    """
    
    cur_exec_path_str = os.getcwd()
    while cur_exec_path_str != "/":
        if existMangoRepo(cur_exec_path_str):
            return cur_exec_path_str
        cur_exec_path_str = os.path.dirname(cur_exec_path_str)
    raise FileNotFoundError("mango repository not found")

def splitCommand(command_str: str) -> tuple[str, str]:
    """splits a command and returns (submodule_path, binding)
    
    Format: (sub1:sub2:)binding
    
    Keyword arguments:
    - command_str -- the command string to split
    
    Return: a tuple corresponding to (submodule_path, binding)
    """
    
    if ':' in command_str:
        split_command = command_str.split(':')
        binding = split_command[-1]
        submodule_path = ':'.join(split_command[:-1])
        return submodule_path, binding
    else:
        return "", command_str

def mapSubmodulePath(submodule_path_str: str, base_path: str = ".", appendReturn: bool = False) -> str:
    """maps a submodule path to its real os path, relative to the parent .mango folder
    
    Keyword arguments:
    - submodule_path_str -- the submodule path to map
    - base_path -- base directory used to resolve the submodule path
    Return: the real os path of the submodule, relative to the base path
    """
    
    os_path = "."
    if not submodule_path_str:
        return os_path
    for submodule in submodule_path_str.split(':'):
        os_path = os.path.join(os_path, ".submodules", submodule)
    candidate_path = os.path.join(base_path, os_path)
    if not os.path.exists(candidate_path):
        raise FileNotFoundError("submodule path does not exist")
    if appendReturn:
        return candidate_path
    else:
        return os_path

def mangoFind(mango_path_str: str, command: str) -> tuple[str | None, bool]:
    """find the script that corresponds to a command in a mango module
    
    Keyword arguments:
    - mango_path_str -- the path to the .mango folder
    - command_name -- the command typed in by the user
    
    Return: the path to the script if it exists, None if not
    """
    
    print(f"Called: mangoFind({mango_path_str}, {command})", file=sys.stderr)
    
    def handleSubmoduleExport(submodule_name: str, cmd: str) -> tuple[str | None, bool]:
        """Handle syntax [submodule] * for exporting all bindings"""
        try:
            submodule_os_path = os.path.join(mango_path_str, mapSubmodulePath(submodule_name, base_path=mango_path_str))
        except FileNotFoundError:
            return None, False
        return mangoFind(submodule_os_path, cmd)
    
    def handleSubmoduleRebind(submodule_name: str, old_binding: str, new_bindings: list[str], cmd: str) -> tuple[str | None, bool]:
        """Handle syntax [submodule] old_binding: new_binding1 new_binding2"""
        if cmd not in new_bindings:
            return None, False
        try:
            submodule_os_path = os.path.join(mango_path_str, mapSubmodulePath(submodule_name, base_path=mango_path_str))
        except FileNotFoundError:
            return None, False
        return mangoFind(submodule_os_path, old_binding)
    
    try:
        submodule_path, binding = splitCommand(command)
        try:
            mapped_mango_path = os.path.join(mango_path_str, mapSubmodulePath(submodule_path, base_path=mango_path_str))
        except FileNotFoundError:
            return None, False
        with open(os.path.join(mapped_mango_path, ".instructions"), "r") as instructions_file:
            for line in instructions_file:
                line = line.strip()
                # print(line)
                if (len(line) == 0 or line.startswith("#")):
                    continue
                if line.startswith('['):
                    # New syntax for submodule handling
                    if ']' not in line:
                        raise SyntaxError("invalid submodule syntax: missing closing bracket")
                    
                    # Extract submodule name and content
                    content_start = line.find(']') + 1
                    if content_start >= len(line):
                        raise SyntaxError("invalid submodule syntax: no content after bracket")
                    
                    submodule_name = line[1:line.find(']')].strip()
                    content = line[content_start:].strip()
                    
                    if not content:
                        raise SyntaxError("invalid submodule syntax: empty content")
                    
                    # Handle export all syntax: [submodule] *
                    if content == '*':
                        callback = handleSubmoduleExport(submodule_name, command)
                        if callback[0] is not None:
                            return callback
                        else:
                            continue
                    
                    # Handle rebind syntax: [submodule] old_binding: new_binding1 new_binding2
                    if ':' in content:
                        parts = content.split(':', 1)
                        if len(parts) != 2:
                            raise SyntaxError("invalid submodule rebind syntax")
                        old_binding = parts[0].strip()
                        new_bindings = parts[1].strip().split()
                        callback = handleSubmoduleRebind(submodule_name, old_binding, new_bindings, command)
                        if callback[0] is not None:
                            return callback
                        else:
                            continue
                    else:
                        raise SyntaxError("invalid submodule syntax: unexpected content format")
                
                # Regular script binding
                use_source = False
                if line.startswith('*'):
                    use_source = True
                    line = line[1:]
                colon_count = line.count(":")
                if colon_count == 0:
                    raise SyntaxError("a non-derivative command must have a binding field")
                elif colon_count == 1:
                    script, bindings = line.split(":")
                    bindings = bindings.split()
                    if binding in bindings:
                        return os.path.join(mapped_mango_path, script), use_source
                else:
                    raise SyntaxError("invalid syntax: too many colons in line. Use [submodule] old_binding: new_binding1 new_binding2 for rebind syntax")
        return None, False
    except Exception as e:
        print("Error occurred when parsing repo: " + mango_path_str, file=sys.stderr)
        raise SyntaxError("invalid .instructions file") from e

def mangoFindFromRepo(repo_path_str: str, command: str) -> tuple[str | None, bool]:
    """find the script that corresponds to a command in a mango repository
    
    Keyword arguments:
    - repo_path_str -- the string the mango repository
    - command -- the command typed in by the user
    
    Return: the path to the script if it exists, None if not
    """
    
    if not existMangoRepo(repo_path_str):
        return None, False
    return mangoFind(os.path.join(repo_path_str, ".mango"), command)

def mangoRecursiveFindFromRepo(repo_path_str: str, command: str) -> tuple[str | None, bool]:
    """find the script that corresponds to a command in a mango repository, recursively, by going up the directory tree
    
    Keyword arguments:
    - repo_path_str -- the string the mango repository
    - command -- the command typed in by the user, with the host flag `@` removed
    
    Return: the string of the script if it exists, None if not
    """
    while repo_path_str != "/":
        script_path, use_source = mangoFindFromRepo(repo_path_str, command)
        if script_path is not None:
            return script_path, use_source
        repo_path_str = os.path.dirname(repo_path_str)
    return None, False

def mangoExecute(script_path_str: str, args: list[str], use_source: bool) -> None:
    """execute a script with arguments
    
    Keyword arguments:
    - script_path_str -- the string of the script to execute
    - args -- the list of arguments to pass to the script
    - use_source -- whether to source the script instead of executing it in a separate shell
    """
    
    if use_source:
        # start a sub-shell with the exact same environment as the current shell
        # join the script and the shell launch with && to prepare the environment
        # this should mimic the effect of sourcing the script
        pre_command = f"source {script_path_str} {' '.join(args)} && exec $SHELL"
        pre_env = os.environ.copy()
        pre_env.update({"MANGO_SOURCE": "true"})
        subprocess.run(
            pre_command, shell=True, executable="/bin/bash", env=pre_env, check=True
        )
    else:
        os.system(f"{script_path_str} " + " ".join(args))

def mango():
    """the main function for the mango script
    """
    
    parser = argparse.ArgumentParser(
        description="Mango: a simple script manager",
        epilog=epilog_message,
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument('-v', '--version', action='version', version=f'Mango {__version__}')
    parser.add_argument('-s', '--source', action='store_true', help="source the script instead of executing it in a separate shell")
    parser.add_argument("command", help="The command to run. Host commands start with @")
    parser.add_argument("args", nargs=argparse.REMAINDER, help="Arguments to pass to the command", default=[])
    args = parser.parse_args()
    script = None
    use_source = args.source
    
    try:
        if (args.command.startswith("@")):
            # this is a host command
            command = args.command[1:]
            script, enforce_source = mangoRecursiveFindFromRepo(closestMangoRepo(), command)
            if script is None:
                print(f"Command '{command}' not found in any repo. Should it exist?", file=sys.stderr)
                return
        else:
            # this is a normal command
            script, enforce_source = mangoFindFromRepo(closestMangoRepo(), args.command)
            if script is None:
                print(f"Command '{args.command}' not found in the current repo. Should it exist?", file=sys.stderr)
                return
        # execute the script
        # if the source is used, a new bash will be spawned and will take over the current python process
        mangoExecute(script, args.args, use_source=use_source or enforce_source)
    except FileNotFoundError as e:
        if str(e) == "mango repository not found":
            print("No mango repository found in any directory. Where's your home mango I wonder :P", file=sys.stderr)
        else:
            raise
    except SyntaxError as e:
        if str(e) == "invalid .instructions file":
            print("Invalid .instructions file. Does it exist? Or is there something wrong with it :<", file=sys.stderr)
        else:
            raise
    except:
        print("An unknown error occurred. I'm sorry, I'm not sure what happened :(", file=sys.stderr)
        raise

if __name__ == '__main__':
    mango()